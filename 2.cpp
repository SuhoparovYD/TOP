#include <iostream>

/* 2. Крестики-нолики

Старинная-добрая игра на страницах всех школьных тетрадей. Поле размером 3х3 представлено в виде двумерного массива
с типом элементов char. Помните тот символьный тип из предыдущего модуля? Теперь он нам и пригодится. Участвуют
два игрока, которые ходят по очереди и ставят в указанные ими в стандартном вводе координаты свой
символ - ‘X’ или ‘O’ (буквы латинского алфавита). Как только у одного из игроков будет установлено подряд 
три крестика или три нолика - он побеждает. Если свободных клеток не осталось, а трёх совпадающих элементов 
не найдено - объявляется ничья. Для простоты, мы не будем рассматривать диагональные совпадения, а только 
строго вертикальные либо строго горизонтальные.

Изначально всё поле инициализируется символом пробела - ‘ ‘. Это можно сделать сразу при объявлении, 
либо с помощью вложенного цикла. На каждом ходе, при занятой клетке или при неверных координатах этой клетки 
должно быть выведено сообщение и игрок должен указать координаты клетки повторно. После каждого хода надо выводить 
в консоль текущее состояние всего игрового поля, для наглядности.

Сделаю ещё одну небольшую подсказку. Проверку на победу игрока, которую надо осуществлять после каждого хода, 
можно сделать с помощью вложенного цикла, сразу проверяя и вертикаль и горизонталь а как именно - попробуйте догадаться сами. */


void draw(char game[3][3]) {
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++)
            std::cout << game[i][j] << " ";
        std::cout << "\n";
    }
}


// поиск линии
int win(char s[3][3], char z) {
    int i, wz = 0;
    for (i = 0; i < 3; i++)
        if (s[i][0] == z && s[i][1] == z && s[i][2] == z) wz++;

    for (i = 0; i < 3; i++)
        if (s[0][i] == z && s[1][i] == z && s[2][i] == z) wz++;

    if (s[0][0] == z && s[1][1] == z && s[2][2] == z) wz++;

    if (s[0][2] == z && s[1][1] == z && s[2][0] == z) wz++;

    return wz;
}

int main() {
    using namespace std;
    setlocale(LC_ALL, "Russian");

    char game[3][3];     // 

    int i, j;

    for (i = 0; i < 3; i++) 
        for (j = 0; j < 3; j++) 
            game[i][j] = '.';     // пробел - не виден
 
    draw(game);

    for (int k = 0; k < 9; k++) {
        do {
            std::cout << "Ход 0 (x,y) : ";  cin >> i >> j;
            if (i > 2 || j > 2 || i < 0 || j < 0) {
                cerr << "Недопустимый ход ";
                continue;
            }
            if (game[i][j] == '.') break;

            cerr << "Клеточка уже занята ";
        } while (1);

        game[i][j] = '0';  draw(game);

        if (win(game, '0')) {
            std::cout << "Выиграли 0 - ки ";
            break;
        }

        do {
            std::cout << "Ход X (x,y) : ";  cin >> i >> j;
            if (i > 2 || j > 2 || i < 0 || j < 0) {
                cerr << "Недопустимый ход ";
                continue;
            }
            if (game[i][j] == '.') break;

            cerr << "Клеточка уже занята ";
        } while (1);

        game[i][j] = 'X';  draw(game);

        if (win(game, 'X')) {
            std::cout << "Выиграли X - ки ";
            break;
        }
    }
    return 0;
}